// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: order.query.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO "order" ("totalPrice", "userId", "status")
VALUES ($1, $2, $3)
RETURNING id, "totalPrice", "userId", status, "createdAt", "updatedAt"
`

type CreateOrderParams struct {
	TotalPrice float64   `json:"totalPrice"`
	UserId     uuid.UUID `json:"userId"`
	Status     string    `json:"status"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder, arg.TotalPrice, arg.UserId, arg.Status)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.TotalPrice,
		&i.UserId,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :exec
INSERT INTO "order_item" ("orderId", "menuItemId", "qty", "unitPrice")
VALUES ($1, $2, $3, $4)
`

type CreateOrderItemParams struct {
	OrderId    uuid.UUID `json:"orderId"`
	MenuItemId uuid.UUID `json:"menuItemId"`
	Qty        int32     `json:"qty"`
	UnitPrice  float64   `json:"unitPrice"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) error {
	_, err := q.db.Exec(ctx, createOrderItem,
		arg.OrderId,
		arg.MenuItemId,
		arg.Qty,
		arg.UnitPrice,
	)
	return err
}

const getAllOrders = `-- name: GetAllOrders :many
SELECT id, "totalPrice", "userId", status, "createdAt", "updatedAt" FROM "order" ORDER BY "createdAt" DESC
`

func (q *Queries) GetAllOrders(ctx context.Context) ([]Order, error) {
	rows, err := q.db.Query(ctx, getAllOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.TotalPrice,
			&i.UserId,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderById = `-- name: GetOrderById :one
SELECT id, "totalPrice", "userId", status, "createdAt", "updatedAt" FROM "order" WHERE "id"=$1
`

func (q *Queries) GetOrderById(ctx context.Context, id uuid.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderById, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.TotalPrice,
		&i.UserId,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderDetails = `-- name: GetOrderDetails :many
SELECT
    o."id" as order_id,
    o."totalPrice" as order_total,
    o."status",
    o."userId",
    o."createdAt",
    oi."id" as order_item_id,
    oi."menuItemId",
    oi."qty",
    oi."unitPrice",
    oi."totalPrice"
FROM "order" o
JOIN "order_item" oi ON o."id" = oi."orderId"
WHERE o."id" = $1
`

type GetOrderDetailsRow struct {
	OrderID     uuid.UUID        `json:"order_id"`
	OrderTotal  float64          `json:"order_total"`
	Status      string           `json:"status"`
	UserId      uuid.UUID        `json:"userId"`
	CreatedAt   pgtype.Timestamp `json:"createdAt"`
	OrderItemID uuid.UUID        `json:"order_item_id"`
	MenuItemId  uuid.UUID        `json:"menuItemId"`
	Qty         int32            `json:"qty"`
	UnitPrice   float64          `json:"unitPrice"`
	TotalPrice  pgtype.Float8    `json:"totalPrice"`
}

func (q *Queries) GetOrderDetails(ctx context.Context, id uuid.UUID) ([]GetOrderDetailsRow, error) {
	rows, err := q.db.Query(ctx, getOrderDetails, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderDetailsRow
	for rows.Next() {
		var i GetOrderDetailsRow
		if err := rows.Scan(
			&i.OrderID,
			&i.OrderTotal,
			&i.Status,
			&i.UserId,
			&i.CreatedAt,
			&i.OrderItemID,
			&i.MenuItemId,
			&i.Qty,
			&i.UnitPrice,
			&i.TotalPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderItems = `-- name: GetOrderItems :many
SELECT id, "orderId", "menuItemId", qty, "unitPrice", "totalPrice" FROM "order_item" WHERE "orderId" = $1
`

func (q *Queries) GetOrderItems(ctx context.Context, orderid uuid.UUID) ([]OrderItem, error) {
	rows, err := q.db.Query(ctx, getOrderItems, orderid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderItem
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderId,
			&i.MenuItemId,
			&i.Qty,
			&i.UnitPrice,
			&i.TotalPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByUserId = `-- name: GetOrdersByUserId :many
SELECT id, "totalPrice", "userId", status, "createdAt", "updatedAt" FROM "order"
WHERE "userId" = $1
ORDER BY "createdAt" DESC
`

func (q *Queries) GetOrdersByUserId(ctx context.Context, userid uuid.UUID) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersByUserId, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.TotalPrice,
			&i.UserId,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserOrdersWithItems = `-- name: GetUserOrdersWithItems :many
SELECT
    o."id" as order_id,
    o."status",
    o."totalPrice" as order_total,
    o."createdAt",
    oi."menuItemId",
    oi."qty",
    oi."unitPrice",
    oi."totalPrice"
FROM "order" o
JOIN "order_item" oi ON o."id" = oi."orderId"
WHERE o."userId" = $1
ORDER BY o."createdAt" DESC
`

type GetUserOrdersWithItemsRow struct {
	OrderID    uuid.UUID        `json:"order_id"`
	Status     string           `json:"status"`
	OrderTotal float64          `json:"order_total"`
	CreatedAt  pgtype.Timestamp `json:"createdAt"`
	MenuItemId uuid.UUID        `json:"menuItemId"`
	Qty        int32            `json:"qty"`
	UnitPrice  float64          `json:"unitPrice"`
	TotalPrice pgtype.Float8    `json:"totalPrice"`
}

func (q *Queries) GetUserOrdersWithItems(ctx context.Context, userid uuid.UUID) ([]GetUserOrdersWithItemsRow, error) {
	rows, err := q.db.Query(ctx, getUserOrdersWithItems, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserOrdersWithItemsRow
	for rows.Next() {
		var i GetUserOrdersWithItemsRow
		if err := rows.Scan(
			&i.OrderID,
			&i.Status,
			&i.OrderTotal,
			&i.CreatedAt,
			&i.MenuItemId,
			&i.Qty,
			&i.UnitPrice,
			&i.TotalPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const verfiyOrder = `-- name: VerfiyOrder :exec
UPDATE "order" SET "status"='complete' WHERE "id"=$1
`

func (q *Queries) VerfiyOrder(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, verfiyOrder, id)
	return err
}
